\documentclass[a4paper, 12pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[backend=bibtex]{biblatex}
\usepackage[breaklinks=true]{hyperref}
\addbibresource{referencias.bib}
\title{Int\'erprete de Brainfuck en Haskell}
\author{Dante Noguera}
\date{}

\begin{document}


\section*{Introducción}

Brainfuck es un lenguaje de programación esotérico, diseñado por Urban Müller en 1993 inspirado por la Máquina de Turing y el lenguaje FALSE.
Se creó con la inteción de que sea simple para tener un compilador menor en tamaño que el de FALSE \footnote{El compilador de FALSE era de 1024 bytes, el de Brainfuck resultó en un tamaño de 240 bytes luego reducido a 200 bytes.} y Turing completo \cite{w}. 
Para esto Müller consideró las siguientes reducciones \cite{y}:
\begin{itemize}
	\item Todos los operadores pueden ser expresados por incrementos y decrementos.
	\item Todos los números pueden ser expresados como incrementos de cero.
	\item Todas las variables pueden ser expresadas como posiciones en un stack.
	\item Lambda cálculo puede ser reemplazado por while \footnote{Müller se refierer en específico al lambda cálculo presente FALSE.}.
\end{itemize}


\section*{Brainfuck}

Un programa en Brainfuck consta de una secuencia de comandos ejecutados secuencialmente que operan sobre una máquina. Los componenetes de dicha máquina son: un arreglo inicializado en cero, un puntero móvil inicializado en el primer byte del arreglo y dos streams de bytes de entrada y salida respectivamente.

\begin{center}
\begin{tabular}{ |l|l|l| } 
 \hline
 Comando & Descripción \\
 \hline
 \textgreater & Mover el puntero una posición a la derecha \\ 
 \textless & Mover el puntero una posición a la izquierda \\ 
 + & Incrementar byte apuntado \\ 
 - & Decrementar byte apuntado \\ 
 . & Escribir byte apuntado en salida\\ 
 , & Leer byte de la entrada y almacenarlo en byte apuntado \\ 
 $[$ & Iterar mientras byte apuntado sea distinto de cero \\ 
 $]$ & Fin de bloque de interación \\ 
 \hline
\end{tabular}
\end{center}

\section*{El intérprete}

En la carpeta src se encuentran los archivos correspondientes al intérprete. Para probar inicialmente el intérprete,
ejecutar ghci Main.hs. El intérprete requiere tener instalado el paquete readline. \\
Los archivos en la carpeta tienen la siguientes funcionalidades:
\begin{itemize}
	\item Common.hs: define los tipos de datos utilizados durante la interpretación.
	\item Main.hs: provee la funcionalidad de entrada y salida del intérprete.
	\item Eval.hs: provee el evaluador.
	\item Parse.y: Especifica la gramática en BNF y provee el lexer. Con este archivo se genera el módulo Parse.hs. Pa-
	ra generar el módulo se utiliza Happy \url{http://www.haskell.org/happy/}. Para generar el módulo Parse.hs
	se ejecuta el comando happy Parse.y.
	\item Parse.hs
\end{itemize}


\section*{Módulos}
Happy \\
Data.Int \\
Control.Applicative (Applicative(..)) \\
Control.Monad (liftM, ap) \\
Control.Monad.Trans.Class \\
Data.Word \\
Data.List \\
System.Console.Readline
Control.Exception (catch,IOException)
Control.Monad.Except
Data.Char
System.IO hiding (print)
System.Environment



%\begin{center}
%\begin{tabular}{ |l|l|l| } 
% \hline
% Nombre & Uso
% \hline
% Data.Word & 
%\end{tabular}
%\end{center}

\newpage
\nocite{*}
\printbibliography[title={Referencias}]
\end{document}