\documentclass[a4paper, 12pt]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage[backend=bibtex]{biblatex}
\usepackage[breaklinks=true]{hyperref}
\usepackage{ amssymb }
\usepackage{graphicx}
\graphicspath{ {./alp_final/} }
\addbibresource{referencias.bib}
\title{Int\'erprete de Brainfuck en Haskell}
\author{Dante Noguera}
\date{}

\begin{document}


\section*{Introducción}

Brainfuck es un lenguaje de programación esotérico, diseñado por Urban Müller en 1993 inspirado por la Máquina de Turing y el lenguaje FALSE.
Se quizo que sea simple, tener un compilador menor que el de FALSE \footnote{El compilador de FALSE era de 1024 bytes, el de Brainfuck resultó en un tamaño de 240 bytes luego reducido a 200 bytes.} y Turing completo. 
Para esto Müller consideró las siguientes reducciones \cite{y}:
\begin{itemize}
	\item Todos los operadores pueden ser expresados por incrementos y decrementos.
	\item Todos los números pueden ser expresados como incrementos de cero.
	\item Todas las variables pueden ser expresadas como posiciones en un stack.
	\item Las funciones anónimas pueden ser reemplazadas por bucles while.
\end{itemize}


\section*{Brainfuck}

Un programa en Brainfuck es una lista de comandos ejecutados secuencialmente que operan sobre una máquina virtual. Los componenetes de dicha máquina son: un arreglo inicializado en cero de 30000 bytes, un puntero móvil inicializado en el primer byte del arreglo y dos streams de bytes de entrada y salida.

\begin{center}
\begin{tabular}{ |l|l|l| } 
 \hline
 Comando & Descripción \\
 \hline
 \textgreater & Mover el puntero una posición a la derecha \\ 
 \textless & Mover el puntero una posición a la izquierda \\ 
 + & Incrementar byte apuntado \\ 
 - & Decrementar byte apuntado \\ 
 . & Escribir byte apuntado en salida\\ 
 , & Leer byte de la entrada y almacenar en byte apuntado \\ 
 $[$ & Iterar mientras el byte apuntado sea distinto de cero \\ 
 $]$ & Fin de bloque de interación \\ 
 \hline
\end{tabular}
\end{center}

Cualquier otro caracter es ignorado.
\section*{Intérprete}

\subsection*{Estructura}

En la carpeta \textbf{src} se encuentran los archivos correspondientes al intérprete. Para lanzarlo
ejecutar \textbf{ghci Main.hs} y \textbf{main},o \textbf{ghc Main.hs} y \textbf{./Main}. \\
Archivos en \textbf{src}:
\begin{itemize}
	\item \textbf{Common.hs}: define los tipos de datos utilizados durante la interpretación.
	\item \textbf{Main.hs}: provee la funcionalidad de entrada y salida del intérprete.
	\item \textbf{Eval.hs}: provee el evaluador.
	\item \textbf{Parse.y}: especifica la gramática en BNF y lexer. Con este archivo se genera el módulo \textbf{Parse.hs} ejecutando \textbf{happy Parse.y}.
	Happy: \url{http://www.haskell.org/happy/}.
	\item \textbf{Parse.hs}.
\end{itemize}

En la carpeta \textbf{ejemplos} se pueden encontrar programas para correr en el intérprete. \\


\subsection*{Decisiones de diseño}

\begin{itemize}
	\item Cada programa se corre sobre una nueva máquina.
	\item Solo se pueden leer enteros. Si el entero es mayor a un byte se le aplica $mod 256$. Por ejemplo 256
	se lee como 0, 1000 como 232, -1 como 255. EOL es una excepción, cuando se lee se inserta 0 en el byte apuntado.
	\item El comando . imprime en código ASCII.
	\item Al final se muestra el último valor apuntado.
\end{itemize}

\begin{figure}[h]
\includegraphics[scale=0.7]{inter}
\centering
\end{figure}

\subsection*{Errores}

\begin{center}
\begin{tabular}{ |l|l|l| } 
 \hline
 Nombre & Mensaje del intérprete & Motivo \\
 \hline
 pointE & Puntero fuera de límites & El puntero se decrementó cuando valía 0 \\
        &                          & o aumentó cuando valía 29999. \\
 readE & Error de lectura & Se leyó un dato de tipo no entero. \\
 \hline
\end{tabular}
\end{center}


\section*{Librerías}

\begin{center}
\begin{tabular}{ |l|l| } 
 \hline
 Nombre & Archivo(s) \\
 \hline
 Data.Word & Common - Eval - Main \\
 Data.Char & Eval - Main \\
 Data.Int & Common \\
 Data.List & Main \\
 Text.Read & Eval \\
 Control.Monad & Common \\
 Control.Monad.Except & Main \\ 
 Control.Monad.Trans.Class & Common - Eval \\
 Control.Applicative & Common \\
 Control.Exception & Main \\ 
 System.IO & Main \\ 
 System.Console.Readline & Main \\ 
 System.Environment & Main \\ 
 \hline
\end{tabular}
\end{center}

Las librerías \textbf{Control.Monad.Except}, \textbf{Control.Monad.Trans.Class} y \textbf{System.Console.Readline} no pertenecen a \textbf{base} deben instalarse aparte.

\newpage
\nocite{*}
\printbibliography[title={Referencias}]
\end{document}